/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define RCC_BASE_ADDR			0x40023800UL
#define RCC_CFGR_REG_OFFSET		0x08UL
#define RCC_CR_REG_OFFSET		0x00UL
#define RCC_CR_REG_ADDR			(RCC_BASE_ADDR + RCC_CR_REG_OFFSET)
#define RCC_CFGR_REG_ADDR 		(RCC_BASE_ADDR + RCC_CFGR_REG_OFFSET)


int main(void)
{

	// enable the HSE clock using the HSE bypass
	// ensure HSE use is disabled prior
	uint32_t *pRccCrReg = (uint32_t*) RCC_CR_REG_ADDR;
	uint32_t *pRccCfgrReg = (uint32_t*) RCC_CFGR_REG_ADDR;
	*pRccCrReg &= ~(1 << 16);
	*pRccCrReg |= (1 << 18);
	*pRccCrReg |= (1 << 16);

	// wait for HSE clock stability
	while(!(*pccCr & (1 << 17)));

	// switch SYSCLK to HSE
	*pRccCfgrReg |= (1 << 0);

	// use MC01 settings to expose CLK reading
	// select HSE as clock source for MCO1
	uint32_t *pRccCfgrReg = (uint32_t*) RCC_CFGR_REG_ADDR;
	*pRccCfgrReg |= ~(0x2 << 21);

	// enable AHB1 for GPIOA peripheral
	uint32_t *pRCCAhb1Enr = (uint32_t*) (RCC_BASE_ADDR + 0x50);
	*pRCCAhb1Enr |= (1 << 0);

	// set PA8 to use alternative function mode
	uint32_t *pGPIOAModeReg = (uint32_t*) (GPIOA_BASE_ADDR + 0x00);
	*pGPIOAModeReg &= ~(0x03 << 16);
	*pGPIOAModeReg |= (0x2 << 16);

	// select which AFR to use
	uint32_t *pGPIOAAltFunHighReg = (uint32_t*) (GPIOA_BASE_ADDR + 0x24);
	*pGPIOAAltFunHighReg &= (0xF << 0);


    /* Loop forever */
	for(;;);
}
